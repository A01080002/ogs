/**
 * \file
 * \author Thomas Fischer
 * \date   2011-03-01
 * \brief  Implementation of the generateBCandGLI tool.
 *
 * \copyright
 * Copyright (c) 2012-2015, OpenGeoSys Community (http://www.opengeosys.org)
 *            Distributed under a Modified BSD License.
 *              See accompanying file LICENSE.txt or
 *              http://www.opengeosys.org/project/license
 *
 */

// STL
#include <algorithm>
#include <fstream>

// Qt
#include <QString>

// GeoLib
#include "GEOObjects.h"
#include "SurfaceVec.h"
#include "GeoLib/Triangle.h"

#include "Applications/ApplicationsLib/ProjectData.h"

// FileIO
#include "XmlIO/Qt/XmlGmlInterface.h"

int main (int argc, char* argv[])
{
	if (argc == 1)
	{
		std::cout << "Usage: " << argv[0] << " gml-file" << std::endl;
		return -1;
	}
	GeoLib::GEOObjects geo_objs;
	FileIO::XmlGmlInterface xml(geo_objs);
	std::string fname (argv[1]);
	xml.readFile(QString::fromStdString (fname));

	std::vector<std::string> geo_names;
	geo_objs.getGeometryNames (geo_names);
	if (geo_names.empty ())
	{
		std::cout << "no geometries found" << std::endl;
		return -1;
	}
	const GeoLib::SurfaceVec* sfc_vec (geo_objs.getSurfaceVecObj(geo_names[0]));
	if (!sfc_vec)
	{
		std::cout << "could not found surfaces" << std::endl;
		return -1;
	}
	const std::size_t n_sfc (sfc_vec->size());

	std::vector<std::size_t> sfc_pnt_ids;
	for (std::size_t k(0); k < n_sfc; k++)
	{
		std::string sfc_name;
		if (sfc_vec->getNameOfElementByID(k, sfc_name))
			if (sfc_name.find ("Terrain") != std::string::npos)
			{
				std::cout << k << ": " << sfc_name << std::endl;
				GeoLib::Surface const* sfc (sfc_vec->getElementByName(sfc_name));
				const std::size_t n_triangles (sfc->getNTriangles());
				for (std::size_t j(0); j < n_triangles; j++)
				{
					GeoLib::Triangle const* tri ((*sfc)[j]);
					for (std::size_t i(0); i < 3; i++)
						sfc_pnt_ids.push_back ((*tri)[i]);
				}
			}
	}

	// make entries unique
	std::cout << "make points unique ... " << std::flush;
	std::sort (sfc_pnt_ids.begin(), sfc_pnt_ids.end());
	std::vector<std::size_t>::iterator it (sfc_pnt_ids.begin());
	while (it != sfc_pnt_ids.end())
	{
		std::vector<std::size_t>::iterator next (it);
		++next;
		if (next != sfc_pnt_ids.end())
		{
			if (*it == *next)
				it = sfc_pnt_ids.erase (it);
			else
				++it;
		}
		else
			++it;
	}
	std::cout << "done" << std::endl;

	std::vector<GeoLib::Point*> const* geo_pnts (geo_objs.getPointVec(geo_names[0]));
	// write gli file and bc file
	std::ofstream gli_out ("TB.gli");
	std::ofstream bc_out ("TB.bc");
	bc_out << "// file generated by " << argv[0] << "\n";
	if (gli_out && bc_out)
	{
		gli_out << "#POINTS" << "\n";
		for (std::size_t k(0); k < sfc_pnt_ids.size(); k++)
		{
			gli_out << k << " " << *((*geo_pnts)[sfc_pnt_ids[k]]) << " $NAME " << k <<
			"\n";
			// boundary condition
			bc_out << "#BOUNDARY_CONDITION" << "\n";
			bc_out << "\t$PCS_TYPE" << "\n" << "\t\tGROUNDWATER_FLOW" << "\n";
			bc_out << "\t$PRIMARY_VARIABLE" << "\n" << "\t\tHEAD" << "\n";
			bc_out << "\t$GEO_TYPE" << "\n" << "\t\tPOINT " << k << "\n";
			bc_out << "\t$DIS_TYPE" << "\n" << "\t\tCONSTANT " <<
			(*((*geo_pnts)[sfc_pnt_ids[k]]))[2] << "\n";
		}
		gli_out << "#STOP" << "\n";
		bc_out << "#STOP" << "\n";
		gli_out.close ();
		bc_out.close ();
	}
}
